<!DOCTYPE html>
<html lang="en-us" prefix="og: http://ogp.me/ns#"><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	
	<link rel="icon" type="image/png" href="/favicon.ico">
	
	
	<title>Making Sense of Azure Durable Functions | Mikhail Shilkov</title>
	
	
	
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.1/css/all.min.css" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">
	
	<link rel="stylesheet" href="/sass/main.css">

	
	
	<meta property="og:title" content="Making Sense of Azure Durable Functions" />
	<meta property="og:description" content="Why and How of Stateful Workflows on top of serverless functions" />
	<meta property="og:type" content="article" />
	<meta property="og:url" content="https://mikhail.io/2018/12/making-sense-of-azure-durable-functions/" />

	
	
	
	<meta property="og:image" content="https://mikhail.io/2018/12/making-sense-of-azure-durable-functions/teaser.jpg" />
	
	


	
	
	<meta property="article:tag" content="Azure" />
	
	<meta property="article:tag" content="Azure Functions" />
	
	<meta property="article:tag" content="Serverless" />
	
	<meta property="article:tag" content="Workflows" />
	
	<meta property="article:tag" content="Azure Durable Functions" />
	

	
	<meta name="twitter:card" content="summary_large_image"/>
	
	<meta name="twitter:image" content="https://mikhail.io/2018/12/making-sense-of-azure-durable-functions/teaser.jpg"/>
	

	<meta name="twitter:title" content="Making Sense of Azure Durable Functions"/>
	<meta name="twitter:description" content="Why and How of Stateful Workflows on top of serverless functions"/>
	<meta name="twitter:creator" content="@MikhailShilkov"></meta>
</head>
<body><script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<script type="text/javascript">
    google.charts.load("current", {packages:["corechart"]});
    function addChart(make) {
        google.charts.setOnLoadCallback(drawChart);
        function drawChart() {
            const data = new google.visualization.DataTable();

            const options = {
                height: 420,  
                chartArea: { width: '85%', height: '70%' },
                legend: 'none',
                hAxis: { minValue: 0 },
                vAxis: {},
                series: {      
                    0: { tooltip : false}
                }
            };
            const chart = make(data, options);
            options.hAxis.textStyle = options.hAxis.titleTextStyle 
                = options.vAxis.textStyle = options.vAxis.titleTextStyle = { fontName: 'Merriweather' };

            chart.draw(data, options);
        }
    }
</script>
<nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container pr-0">
        <a class="navbar-brand" href="/">
            <img class="author-thumb" src="/images/author.jpg" alt="Mikhail Shilkov">
            <span class="text-primary">Mikhail Shilkov</span>
        </a>

        
               


        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-controls="navbarSupportedContent"
            aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                
                <li class="nav-item ">
                    <a class="nav-link" href="/tags/">TOPICS</a>
                </li>
                
                <li class="nav-item ">
                    <a class="nav-link" href="/archives/">ARCHIVES</a>
                </li>
                
                <li class="nav-item ">
                    <a class="nav-link" href="/talks/">TALKS</a>
                </li>
                
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">ABOUT</a>
                </li>
                <li class="nav-item">
    <a class="nav-link" href="https://mikhail.io/feed/"><i class="fas fa-rss social-icon" aria-hidden="true"></i></a>
</li>

<li class="nav-item">
    <a class="nav-link" href="https://www.twitter.com/MikhailShilkov"><i class="fab fa-twitter social-icon" aria-hidden="true"></i></a>
</li>


<li class="nav-item">
    <a class="nav-link" href="https://dev.to/mikhailshilkov"><i class="fab fa-dev social-icon" aria-hidden="true"></i></a>
</li>


<li class="nav-item">
    <a class="nav-link" href="https://medium.com/@MikhailShilkov"><i class="fab fa-medium social-icon" aria-hidden="true"></i></a>
</li>


<li class="nav-item">
    <a class="nav-link" href="https://github.com/MikhailShilkov"><i class="fab fa-github social-icon" aria-hidden="true"></i></a>
</li>


<li class="nav-item">
    <a class="nav-link" href="https://www.linkedin.com/in/MikhailShilkov"><i class="fab fa-linkedin social-icon" aria-hidden="true"></i></a>
</li>

</ul>
        </div>
        
    </div>
</nav>


        <div class="container">

<div class="main-content">
    
    <div class="container">
        <div class="row">
            
            <div class="col-lg-2 pl-0"><div class="share">
    <ul>
        <li class="ml-1 mr-1" title="Say 'Thank You' for this article">
            <a href="#" onclick="heart();return false;">
                <i class="fas fa-heart" style="color: red"></i>
            </a>
            <div class="count" style="float: right; padding-left: .5em; padding-top: .25em" id="heartcount"></div>
        </li>

        <li class="ml-1 mr-1" title="Tweet this article">
            <a target="_blank"
                href="https://twitter.com/intent/tweet?text=Making%20Sense%20of%20Azure%20Durable%20Functions%20by%20@MikhailShilkov&url=https%3a%2f%2fmikhail.io%2f2018%2f12%2fmaking-sense-of-azure-durable-functions%2f"
                onclick="window.open(this.href, 'twitter-share', 'width=550,height=435');return false;">
                <i class="fab fa-twitter"></i>
            </a>
        </li>

        <li class="ml-1 mr-1" title="See the responses or write a response">
            <a href="#comments">
                <i class="fas fa-comment"></i>
            </a>
        </li>
    </ul>
</div></div>
            
            <div class="col-lg-9 flex-first flex-lg-unordered">

                <div class="mainheading">
                    
                    <h1 class="posttitle">Making Sense of Azure Durable Functions</h1>
                    
                    <div class="post-top-meta">
                        <div>
                            
                                
                                <span class="post-date">Published on Dec 7, 2018
                                
                            
                            
                        &nbsp;&middot;&nbsp; 22 min read</span></span>
                        </div>
                    </div>
                </div>
                
                
                
            </div>
        </div>
        <div class="row">
            <div class="col-lg-11 offset-lg-1 flex-first flex-lg-unordered">
                <img class="featured-image img-fluid" src="teaser.jpg" alt="thumbnail for this post">
            </div>
        </div>
        <div class="row">
            <div class="col-lg-2 pl-0">
            </div>
            <div class="col-lg-9 flex-first flex-lg-unordered">
                
                
                

                
                <div class="article-post">
                    <p>Stateful Workflows on top of Stateless Serverless Cloud Functionsâ€”this is the essence
of the Azure Durable Functions library. That&rsquo;s a lot of fancy words in one sentence, and they
might be hard for the majority of readers to understand.</p>
<p>Please join me on the journey where I&rsquo;ll try to explain how those buzzwords fit
together. I will do this in 3 steps:</p>
<ul>
<li>Describe the context of modern cloud applications relying on serverless architecture;</li>
<li>Identify the limitations of basic approaches to composing applications out of the simple building blocks;</li>
<li>Explain the solutions that Durable Functions offer for those problems.</li>
</ul>
<h2 id="microservices">Microservices</h2>
<p>Traditionally, server-side applications were built in a style which is now referred to as
<strong>Monolith</strong>. If multiple people and teams were developing parts of the same application, they
mostly contributed to the same code base. If the code base were structured well, it would have
some distinct modules or components, and a single team would typically own each module:</p>
<p><img src="monolith.png" alt="Monolith"></p>
<figcaption><h4>Multiple components of a monolithic application</h4></figcaption>
<p>Usually, the modules would be packaged together at build time and then deployed as a single
unit, so a lot of communication between modules would stay inside the OS process.</p>
<p>Although the modules could stay loosely coupled over time, the coupling almost always occurred
on the level of the data store because all teams would use a single centralized database.</p>
<p>This model works great for small- to medium-size applications, but it turns out that teams
start getting in each other&rsquo;s way as the application grows since synchronization of contributions
takes more and more effort.</p>
<p>As a complex but viable alternative, the industry came up with a revised service-oriented
approach commonly called <strong>Microservices</strong>. The teams split the big application into &ldquo;vertical slices&rdquo;
structured around the distinct business capabilities:</p>
<p><img src="microservices.png" alt="Microservices"></p>
<figcaption><h4>Multiple components of a microservice-based application</h4></figcaption>
<p>Each team then owns a whole verticalâ€”from public communication contracts, or even UIs, down
to the data storage. Explicitly shared databases are strongly discouraged. Services talk to each
other via documented and versioned public contracts.</p>
<p>If the borders for the split were selected wellâ€”and that&rsquo;s the most tricky partâ€”the
contracts stay stable over time, and thin enough to avoid too much chattiness. This gives
each team enough autonomy to innovate at their best pace and to make independent technical decisions.</p>
<p>One of the drawbacks of microservices is the change in deployment model. The services are now
deployed to separate servers connected via a network:</p>
<p><img src="distributed-system.png" alt="Distributed Systems"></p>
<figcaption><h4>Challenges of communication between distributed components</h4></figcaption>
<p>Networks are fundamentally unreliable: they work just fine most of the time, but when they
fail, they fail in all kinds of unpredictable and least desirable manners. There are books
written on the topic of distributed systems architecture. TL;DR: it&rsquo;s hard.</p>
<p>A lot of the new adopters of microservices tend to ignore such complications. REST over HTTP(S) is the
dominant style of connecting microservices. Like any other synchronous communication
protocol, it makes the system brittle.</p>
<p>Consider what happens when one service becomes temporary unhealthy: maybe its database goes offline, or it&rsquo;s struggling to
keep up with the request load, or a new version of the service is being deployed. All the requests to the problematic service start
failingâ€”or worseâ€”become very slow. The dependent service waits for the response, and
thus blocks all incoming requests of its own. The error propagates upstream very quickly causing cascading
failures all over the place:</p>
<p><img src="cascading-failures.png" alt="Cascading Failures"></p>
<figcaption><h4>Error in one component causes cascading failures</h4></figcaption>
<p>The application is down. Everybody screams and starts the blame war.</p>
<h2 id="event-driven-applications">Event-Driven Applications</h2>
<p>While cascading failures of HTTP communication can be mitigated with patterns like a circuit breaker
and graceful degradation, a better solution is to switch to the asynchronous style of communication
as the default. Some kind of persistent queueing service is used as an intermediary.</p>
<p>The style of application architecture which is based on sending events between services
is known as <strong>Event-Driven</strong>. When a service does something useful, it publishes an eventâ€”a record
about the fact which happened to its business domain. Another service listens to the published events and
executes its own duty in response to those facts:</p>
<p><img src="event-driven.png" alt="Event-Driven Application"></p>
<figcaption><h4>Communication in event-driven applications</h4></figcaption>
<p>The service that produces events might not know about the consumers. New event subscribers can
be introduced over time. This works better in theory than in practice, but the services tend to
get coupled less.</p>
<p>More importantly, if one service is down, other services don&rsquo;t catch fire immediately. The
upstream services keep publishing the events, which build up in the queue but can be stored safely
for hours or days. The downstream services might not be doing anything useful for this particular
flow, but it can stay healthy otherwise.</p>
<p>However, another potential issue comes hand-in-hand with loose coupling: low cohesion.
As Martin Fowler notices in his essay
<a href="https://martinfowler.com/articles/201701-event-driven.html">What do you mean by &ldquo;Event-Driven&rdquo;</a>:</p>
<blockquote>
<p>It&rsquo;s very easy to make nicely decoupled systems with event notification, without realizing
that you&rsquo;re losing sight of the larger-scale flow.</p></blockquote>
<p>Given many components that publish and subscribe to a large number of event types, it&rsquo;s easy to stop
seeing the forest for the trees. Combinations of events usually constitute gradual workflows executed
in time. A workflow is more than the sum of its parts, and understanding of the high-level flow is
paramount to controlling the system behavior.</p>
<p>Hold this thought for a minute; we&rsquo;ll get back to it later. Now it&rsquo;s time to talk <em>cloud</em>.</p>
<h2 id="cloud">Cloud</h2>
<p>The birth of public cloud changed the way we architect applications. It made many things
much more straightforward: provisioning of new resources in minutes instead of months, scaling elastically
based on demand, and resiliency and disaster recovery at the global scale.</p>
<p>It made other things more complicated. Here is the picture of the global Azure network:</p>
<p><img src="azure-network.png" alt="Azure Network"></p>
<figcaption><h4>Azure locations with network connections</h4></figcaption>
<p>There are good reasons to deploy applications to more than one geographical location:
among others, to reduce network latency by staying close to the customer, and to achieve resilience through
geographical redundancy. Public Cloud is the ultimate distributed system. As you remember,
distributed systems are hard.</p>
<p>There&rsquo;s more to that. Each cloud provider has dozens and dozens of managed services, which is
the curse and the blessing. Specialized services are great to provide off-the-shelf solutions
to common complex problems. On the flip side, each service has distinct properties regarding
consistency, resiliency and fault tolerance.</p>
<p>In my opinion, at this point developers have to embrace the public cloud and apply the distributed
system design on top of it. If you agree, there is an excellent way to approach it.</p>
<h2 id="serverless">Serverless</h2>
<p>The slightly provocative term <strong>serverless</strong> is used to describe cloud services that do not
require provisioning of VMs, instances, workers, or any other fixed capacity to run
custom applications on top of them. Resources are allocated dynamically and transparently,
and the cost is based on their actual consumption, rather than on pre-purchased capacity.</p>
<p>Serverless is more about operational and economical properties of the system than about the
technology per se. Servers do exist, but they are someone else&rsquo;s concern. You don&rsquo;t manage
the uptime of serverless applications: the cloud provider does.</p>
<p>On top of that, you pay for what you use, similar to the consumption of other commodity resources
like electricity. Instead of buying a generator to power up your house, you just purchase energy
from the power company. You lose some control (e.g., no way to select the voltage), but this is fine
in most cases. The great benefit is no need to buy and maintain the hardware.</p>
<p>Serverless compute does the same: it supplies standard services on a pay-per-use basis.</p>
<p>If we talk more specifically about Function-as-a-Service offerings like Azure Functions, they
provide a standard model to run small pieces of code in the cloud.
You zip up the code or binaries and send it to Azure; Microsoft takes care of all the
hardware and software required to run it. The infrastructure automatically scales up or down based
on demand, and you pay per request, CPU time and memory that the application consumed.
No usageâ€”no bill.</p>
<p>However, there&rsquo;s always a &ldquo;but&rdquo;. FaaS services come with an opinionated development model that
applications have to follow:</p>
<ul>
<li>
<p><strong>Event-Driven</strong>: for each serverless function you have to define a specific triggerâ€”the
event type which causes it to run, be it an HTTP endpoint or a queue message;</p>
</li>
<li>
<p><strong>Short-Lived</strong>: functions can only run up to several minutes, and preferably for a few seconds
or less;</p>
</li>
<li>
<p><strong>Stateless</strong>: as you don&rsquo;t control where and when function instances are provisioned or
deprovisioned, there is no way to store data within the process between requests reliably;
external storage has to be utilized.</p>
</li>
</ul>
<p>Frankly speaking, the majority of existing applications don&rsquo;t really fit into this model.
If you are lucky to work on a new application (or a new module of it), you are in better shape.</p>
<p>A lot of the serverless applications may be designed to look somewhat similar to this example
from <a href="https://www.serverless360.com/blog/building-reactive-solution-with-azure-event-grid">the Serverless360 blog</a>:</p>
<p><img src="serviceful-example.png" alt="Serviceful Serverless Application"></p>
<figcaption><h4>Sample application utilizing "serviceful" serverless architecture</h4></figcaption>
<p>There are 9 managed Azure services working together in this app. Most of them have a unique purpose, but
the services are all glued together with Azure Functions. An image is uploaded to Blob Storage, an
Azure Function calls Vision API to recognize the license plate and send the result to Event Grid, another
Azure Function puts that event to Cosmos DB, and so on.</p>
<p>This style of cloud applications is sometimes referred to as <strong>Serviceful</strong> to emphasize the heavy usage
of managed services &ldquo;glued&rdquo; together by serverless functions.</p>
<p>Creating a comparable application without any managed services would be a much harder task,
even more so, if the application has to run at scale. Moreover, there&rsquo;s no way to keep the pay-as-you-go
pricing model in the self-service world.</p>
<p>The application pictured above is still pretty straightforward. The processes
in enterprise applications are often much more sophisticated.</p>
<p>Remember the quote from Martin Fowler about losing sight of the large-scale flow. That was
true for microservices, but it&rsquo;s even more true for the &ldquo;nanoservices&rdquo; of cloud functions.</p>
<p>I want to dive deeper and give you several examples of related problems.</p>
<h2 id="challenges-of-serverless-composition">Challenges of Serverless Composition</h2>
<p>For the rest of the article, I&rsquo;ll define an imaginary business application for booking trips to software
conferences. In order to go to a conference, I need to buy tickets to the conference itself,
purchase the flights, and book a room at a hotel.</p>
<p>In this scenario, it makes sense to create three Azure Functions, each one responsible for one step
of the booking process. As we prefer message passing, each Function emits an event which
the next function can listen for:</p>
<p><img src="conference-booking.png" alt="Conference Booking Application"></p>
<figcaption><h4>Conference booking application</h4></figcaption>
<p>This approach works, however, problems do exist.</p>
<h3 id="flexible-sequencing">Flexible Sequencing</h3>
<p>As we need to execute the whole booking process in sequence, the Azure Functions are wired
one after another by configuring the output of one function to match with the event source of
the downstream function.</p>
<p>In the picture above, the functions&rsquo; sequence is hard-defined. If we were to swap the order of booking
the flights and reserving the hotel, that would require a code changeâ€”at least of the
input/output wiring definitions, but probably also the functions&rsquo; parameter types.</p>
<p>In this case, are the functions <em>really</em> decoupled?</p>
<h3 id="error-handling">Error Handling</h3>
<p>What happens if the Book Flight function becomes unhealthy, perhaps due to the
outage of the third-party flight-booking service? Well, that&rsquo;s why we use asynchronous messaging:
after the function execution fails, the message returns to the queue and is picked
up again by another execution.</p>
<p>However, such retries happen almost immediately for most event sources. This might not
be what we want: an exponential back-off policy could be a smarter idea. At this point,
the retry logic becomes <strong>stateful</strong>: the next attempt should &ldquo;know&rdquo; the history of previous attempts
to make a decision about retry timing.</p>
<p>There are more advanced error-handling patterns too. If executions failures are not
intermittent, we may decide to cancel the whole process and run compensating actions
against the already completed steps.</p>
<p>An example of this is a fallback action: if the flight is not possible (e.g., no routes for this
origin-destination combination), the flow could choose to book a train instead:</p>
<p><img src="fallback-on-error.png" alt="Fallback On Error"></p>
<figcaption><h4>Fallback after 3 consecutive failures</h4></figcaption>
<p>This scenario is not trivial to implement with stateless functions. We could wait until a
message goes to the dead-letter queue and then route it from there, but this is brittle and
not expressive enough.</p>
<h3 id="parallel-actions">Parallel Actions</h3>
<p>Sometimes the business process doesn&rsquo;t have to be sequential. In our reservation scenario,
there might be no difference whether we book a flight before a hotel or vice versa. It could
be desirable to run those actions in parallel.</p>
<p>Parallel execution of actions is easy with the pub-sub capabilities of an event bus: both functions
should subscribe to the same event and act on it independently.</p>
<p>The problem comes when we need to reconcile the outcomes of parallel actions, e.g., calculate the
final price for expense reporting purposes:</p>
<p><img src="fanout-fanin.png" alt="Fan-out / Fan-in"></p>
<figcaption><h4>Fan-out / fan-in pattern</h4></figcaption>
<p>There is no way to implement the Report Expenses block as a single Azure Function: functions
can&rsquo;t be triggered by two events, let alone correlate two <em>related</em> events.</p>
<p>The solution would probably include two functions, one per event, and the shared storage
between them to pass information about the first completed booking to the one who
completes last. All this wiring has to be implemented in custom code. The complexity grows
if more than two functions need to run in parallel.</p>
<p>Also, don&rsquo;t forget the edge cases. What if one of the function fails? How do you make sure there is
no race condition when writing and reading to/from the shared storage?</p>
<h3 id="missing-orchestrator">Missing Orchestrator</h3>
<p>All these examples give us a hint that we need an additional tool to organize low-level
single-purpose independent functions into high-level workflows.</p>
<p>Such a tool can be called an <strong>Orchestrator</strong> because its sole mission is to delegate work
to stateless actions while maintaining the big picture and history of the flow.</p>
<p>Azure Durable Functions aims to provide such a tool.</p>
<h2 id="introducing-azure-durable-functions">Introducing Azure Durable Functions</h2>
<h3 id="azure-functions">Azure Functions</h3>
<p>Azure Functions is the serverless compute service from Microsoft. Functions are event-driven:
each function defines a <strong>trigger</strong>â€”the exact definition of the event source, for instance,
the name of a storage queue.</p>
<p>Azure Functions can be programmed in <a href="https://docs.microsoft.com/en-us/azure/azure-functions/supported-languages">several languages</a>.
A basic Function with a
<a href="https://docs.microsoft.com/azure/azure-functions/functions-bindings-storage-queue">Storage Queue trigger</a>
implemented in C# would look like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>[FunctionName(&#34;MyFirstFunction&#34;)]
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> QueueTrigger(
</span></span><span style="display:flex;"><span>    [QueueTrigger(&#34;myqueue-items&#34;)] <span style="color:#2b91af">string</span> myQueueItem,
</span></span><span style="display:flex;"><span>    ILogger log)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    log.LogInformation(<span style="color:#a31515">$&#34;C# function processed: {myQueueItem}&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>FunctionName</code> attribute exposes the C# static method as an Azure Function named <code>MyFirstFunction</code>.
The <code>QueueTrigger</code> attribute defines the name of the storage queue to listen to. The function body
logs the information about the incoming message.</p>
<h3 id="durable-functions">Durable Functions</h3>
<p><a href="https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-overview">Durable Functions</a>
is a library that brings workflow orchestration abstractions to
Azure Functions. It introduces a number of idioms and tools to define stateful,
potentially long-running operations, and manages a lot of mechanics of reliable communication
and state management behind the scenes.</p>
<p>The library records the history of all actions in Azure Storage services, enabling durability
and resilience to failures.</p>
<p>Durable Functions is
<a href="https://github.com/Azure/azure-functions-durable-extension">open source</a>,
Microsoft accepts external contributions, and the community is quite active.</p>
<p>Currently, you can write Durable Functions in 3 programming languages: C#, F#, and
Javascript (Node.js). All my examples are going to be in C#. For Javascript,
check <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/quickstart-js-vscode">this quickstart</a>
and <a href="https://github.com/Azure/azure-functions-durable-extension/tree/master/samples/javascript">these samples</a>.
For F# see <a href="https://github.com/Azure/azure-functions-durable-extension/tree/master/samples/fsharp">the samples</a>,
<a href="https://github.com/mikhailshilkov/DurableFunctions.FSharp">the F#-specific library</a> and my article
<a href="https://mikhail.io/2018/12/fairy-tale-of-fsharp-and-durable-functions/">A Fairy Tale of F# and Durable Functions</a>.</p>
<p>Workflow building functionality is achieved by the introduction of two additional types
of triggers: Activity Functions and Orchestrator Functions.</p>
<h3 id="activity-functions">Activity Functions</h3>
<p>Activity Functions are simple stateless single-purpose building blocks
that do just one task and have no awareness of the bigger workflow.
A new trigger type,
<code>ActivityTrigger</code>, was introduced to expose functions as workflow steps, as
I explain below.</p>
<p>Here is a simple Activity Function implemented in C#:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>[FunctionName(&#34;BookConference&#34;)]
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">static</span> ConfTicket BookConference([ActivityTrigger] <span style="color:#2b91af">string</span> conference)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">var</span> ticket = BookingService.Book(conference);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#00f">new</span> ConfTicket { Code = ticket };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It has a common <code>FunctionName</code> attribute to expose the C# static method as an
Azure Function named <code>BookConference</code>. The name is important because it is used to
invoke the activity from orchestrators.</p>
<p>The <code>ActivityTrigger</code> attribute defines the trigger type and points to the input
parameter <code>conference</code> which the activity expects to get for each invocation.</p>
<p>The function can return a result of any serializable type; my sample function
returns a simple property bag called <code>ConfTicket</code>.</p>
<p>Activity Functions can do pretty much anything: call other services, load and
save data from/to databases, and use any .NET libraries.</p>
<h3 id="orchestrator-functions">Orchestrator Functions</h3>
<p>The Orchestrator Function is a unique concept introduced by Durable Functions. Its sole
purpose is to manage the flow of execution and data among several activity functions.</p>
<p>Its most basic form chains multiple independent activities into a single
sequential workflow.</p>
<p>Let&rsquo;s start with an example which books a conference ticket, a flight itinerary, and
a hotel room one-by-one:</p>
<p><img src="sequential-workflow.png" alt="Sequential Workflow"></p>
<figcaption><h4>3 steps of a workflow executed in sequence</h4></figcaption>
<p>The implementation of this workflow is defined by another C# Azure Function, this time with
<code>OrchestrationTrigger</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>[FunctionName(&#34;SequentialWorkflow&#34;)]
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">async</span> Task Sequential([OrchestrationTrigger] DurableOrchestrationContext context)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">var</span> conference = <span style="color:#00f">await</span> context.CallActivityAsync&lt;ConfTicket&gt;(<span style="color:#a31515">&#34;BookConference&#34;</span>, <span style="color:#a31515">&#34;ServerlessDays&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">var</span> flight = <span style="color:#00f">await</span> context.CallActivityAsync&lt;FlightTickets&gt;(<span style="color:#a31515">&#34;BookFlight&#34;</span>, conference.Dates);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">await</span> context.CallActivityAsync(<span style="color:#a31515">&#34;BookHotel&#34;</span>, flight.Dates);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Again, attributes are used to describe the function for the Azure runtime.</p>
<p>The only input parameter has type <code>DurableOrchestrationContext</code>. This context is the tool that
enables the orchestration operations.</p>
<p>In particular, the <code>CallActivityAsync</code> method is used three times to invoke three activities one after the other.
The method body looks very typical for any C# code working with a <code>Task</code>-based API. However,
the behavior is entirely different. Let&rsquo;s have a look at the implementation details.</p>
<h2 id="behind-the-scenes">Behind the Scenes</h2>
<p>Let&rsquo;s walk through the lifecycle of one execution of the sequential workflow above.</p>
<p>When the orchestrator starts running, the first <code>CallActivityAsync</code> invocation is made to book the
conference ticket. What actually happens here is that a queue message is sent from the orchestrator
to the activity function.</p>
<p>The corresponding activity function gets triggered by the queue message. It does its job (books the
ticket) and returns the result. The activity function serializes the result and sends it as a queue
message back to the orchestrator:</p>
<p><img src="durable-messaging.png" alt="Durable Functions: Message Passing"></p>
<figcaption><h4>Messaging between the orchestrator and the activity</h4></figcaption>
<p>When the message arrives, the orchestrator gets triggered again and can proceed to the second
activity. The cycle repeatsâ€”a message gets sent to Book Flight activity, it gets triggered, does its
job, and sends a message back to the orchestrator.
The same message flow happens for the third call.</p>
<h3 id="stop-resume-behavior">Stop-resume behavior</h3>
<p>As discussed earlier, message passing is intended to decouple the sender and receiver in time.
For every message in the scenario above, no immediate response is expected.</p>
<p>On the C# level, when the <code>await</code> operator is executed, the code doesn&rsquo;t block the execution of the whole
orchestrator. Instead, it just quits: the orchestrator stops being active and its current step completes.</p>
<p>Whenever a return message arrives from an activity, the orchestrator code restarts. It always starts
with the first line. Yes, this means that the same line is executed multiple times: up to the number of
messages to the orchestrator.</p>
<p>However, the orchestrator stores the history of its past executions in Azure Storage, so the effect of the second pass
of the first line is different: instead of sending a message to the activity it already knows
the result of that activity, so <code>await</code> returns this result back and assigns it to the <code>conference</code> variable.</p>
<p>Because of these &ldquo;replays&rdquo;, the orchestrator&rsquo;s implementation has to be deterministic: don&rsquo;t use
<code>DateTime.Now</code>, random numbers or multi-thread operations; more details
<a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-checkpointing-and-replay#orchestrator-code-constraints">here</a>.</p>
<h3 id="event-sourcing">Event Sourcing</h3>
<p>Azure Functions are stateless, while workflows require a state to keep track of their progress. Every time a new
action towards the workflow&rsquo;s execution happens, the framework automatically records an event in table storage.</p>
<p>Whenever an orchestrator restarts the execution because a new message arrives from its activity,
it loads the complete history of this particular execution from storage. Durable Context uses
this history to make decisions whether to call the activity or return the previously stored result.</p>
<p>The pattern of storing the complete history of state changes as an append-only event store is
known as Event Sourcing. Event store provides several benefits:</p>
<ul>
<li><strong>Durability</strong>â€”if a host running an orchestration fails, the history is retained in
persistent storage and is loaded by the new host where the orchestration restarts;</li>
<li><strong>Scalability</strong>â€”append-only writes are fast and easy to spread over multiple storage servers;</li>
<li><strong>Observability</strong>â€”no history is ever lost, so it&rsquo;s straightforward to inspect and
analyze even after the workflow is complete.</li>
</ul>
<p>Here is an illustration of the notable events that get recorded during our sequential workflow:</p>
<p><img src="event-sourcing.png" alt="Durable Functions: Event Sourcing"></p>
<figcaption><h4>Log of events in the course of orchestrator progression</h4></figcaption>
<h3 id="billing">Billing</h3>
<p>Azure Functions on the serverless consumption-based plan are billed per execution + per duration of
execution.</p>
<p>The stop-replay behavior of durable orchestrators causes the single workflow &ldquo;instance&rdquo; to execute
the same orchestrator function multiple times. This also means paying for several short
executions.</p>
<p>However, the total bill usually ends up being much lower compared to the potential cost of blocking
synchronous calls to activities. The price of 5 executions of 100 ms each is significantly lower
than the cost of 1 execution of 30 seconds.</p>
<p>By the way, the first million executions per month are
<a href="https://azure.microsoft.com/en-us/pricing/details/functions/">at no charge</a>,
so many scenarios incur no cost at all from Azure Functions service.</p>
<p>Another cost component to keep in mind is Azure Storage. Queues and Tables that are used behind the
scenes are charged to the end customer. In my experience, this charge remains close to zero for
low- to medium-load applications.</p>
<p>Beware of unintentional eternal loops or indefinite recursive fan-outs in your orchestrators. Those
can get expensive if you leave them out of control.</p>
<h2 id="error-handling-and-retries">Error-handling and retries</h2>
<p>What happens when an error occurs somewhere in the middle of the workflow? For instance, a third-party
flight booking service might not be able to process the request:</p>
<p><img src="error-handling.png" alt="Error Handling"></p>
<figcaption><h4>One activity is unhealthy</h4></figcaption>
<p>This situation is expected by Durable Functions. Instead of silently failing, the activity function
sends a message containing the information about the error back to the orchestrator.</p>
<p>The orchestrator deserializes the error details and, at the time of replay, throws a .NET exception
from the corresponding call. The developer is free to put a <code>try .. catch</code> block around the call
and handle the exception:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>[FunctionName(&#34;SequentialWorkflow&#34;)]
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">async</span> Task Sequential([OrchestrationTrigger] DurableOrchestrationContext context)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">var</span> conf = <span style="color:#00f">await</span> context.CallActivityAsync&lt;ConfTicket&gt;(<span style="color:#a31515">&#34;BookConference&#34;</span>, <span style="color:#a31515">&#34;ServerlessDays&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">try</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#2b91af">var</span> itinerary = MakeItinerary(<span style="color:#008000">/* ... */</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">await</span> context.CallActivityAsync(<span style="color:#a31515">&#34;BookFlight&#34;</span>, itinerary);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">catch</span> (FunctionFailedException)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#2b91af">var</span> alternativeItinerary = MakeAnotherItinerary(<span style="color:#008000">/* ... */</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">await</span> context.CallActivityAsync(<span style="color:#a31515">&#34;BookFlight&#34;</span>, alternativeItinerary);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">await</span> context.CallActivityAsync(<span style="color:#a31515">&#34;BookHotel&#34;</span>, flight.Dates);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The code above falls back to a &ldquo;backup plan&rdquo; of booking another itinerary. Another typical pattern
would be to run a compensating activity to cancel the effects of any previous actions (un-book the
conference in our case) and leave the system in a clean state.</p>
<p>Quite often, the error might be transient, so it might make sense to retry the failed operation
after a pause. It&rsquo;s a such a common scenario that Durable Functions provides a dedicated API:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#2b91af">var</span> options = <span style="color:#00f">new</span> RetryOptions(
</span></span><span style="display:flex;"><span>    firstRetryInterval: TimeSpan.FromMinutes(1),
</span></span><span style="display:flex;"><span>    maxNumberOfAttempts: 5);
</span></span><span style="display:flex;"><span>options.BackoffCoefficient = 2.0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">await</span> context.CallActivityWithRetryAsync(<span style="color:#a31515">&#34;BookFlight&#34;</span>, options, itinerary);
</span></span></code></pre></div><p>The above code instructs the library to</p>
<ul>
<li>Retry up to 5 times</li>
<li>Wait for 1 minute before the first retry</li>
<li>Increase delays before every subsequent retry by the factor of 2 (1 min, 2 min, 4 min, etc.)</li>
</ul>
<p>The significant point is that, once again, the orchestrator does not block while
awaiting retries. After a failed call, a message is scheduled for the moment in the future
to re-run the orchestrator and retry the call.</p>
<h2 id="sub-orchestrators">Sub-orchestrators</h2>
<p>Business processes may consist of numerous steps. To keep the code of orchestrators manageable,
Durable Functions allows nested orchestrators. A &ldquo;parent&rdquo; orchestrator can call out to child
orchestrators via the <code>context.CallSubOrchestratorAsync</code> method:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>[FunctionName(&#34;CombinedOrchestrator&#34;)]
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">async</span> Task CombinedOrchestrator([OrchestrationTrigger] DurableOrchestrationContext context)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#00f">await</span> context.CallSubOrchestratorAsync(<span style="color:#a31515">&#34;BookTrip&#34;</span>, serverlessDaysAmsterdam);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">await</span> context.CallSubOrchestratorAsync(<span style="color:#a31515">&#34;BookTrip&#34;</span>, serverlessDaysHamburg);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The code above books two conferences, one after the other.</p>
<h2 id="fan-out--fan-in">Fan-out / Fan-in</h2>
<p>What if we want to run multiple activities in parallel?</p>
<p>For instance, in the example above, we could wish to book two conferences, but the
booking order might not matter. Still, when both bookings are completed, we want to combine the results
to produce an expense report for the finance department:</p>
<p><img src="parallel-calls.png" alt="Parallel Calls"></p>
<figcaption><h4>Parallel calls followed by a final step</h4></figcaption>
<p>In this scenario, the <code>BookTrip</code> orchestrator accepts an input parameter with the name of the
conference and returns the expense information. <code>ReportExpenses</code> needs to receive both
expenses combined.</p>
<p>This goal can be easily achieved by scheduling two tasks (i.e., sending two messages) without
awaiting them separately. We use the familiar <code>Task.WhenAll</code> method to await both and combine
the results:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>[FunctionName(&#34;ParallelWorkflow&#34;)]
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">async</span> Task Parallel([OrchestrationTrigger] DurableOrchestrationContext context)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">var</span> amsterdam = context.CallSubOrchestratorAsync(<span style="color:#a31515">&#34;BookTrip&#34;</span>, serverlessDaysAmsterdam);
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">var</span> hamburg   = context.CallSubOrchestratorAsync(<span style="color:#a31515">&#34;BookTrip&#34;</span>, serverlessDaysHamburg);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">var</span> expenses = <span style="color:#00f">await</span> Task.WhenAll(amsterdam, hamburg);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">await</span> context.CallActivityAsync(<span style="color:#a31515">&#34;ReportExpenses&#34;</span>, expenses);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Remember that awaiting the <code>WhenAll</code> method doesn&rsquo;t synchronously block the orchestrator. It quits
the first time and then restarts two times on reply messages received from activities.
The first restart quits again, and only the second restart makes it past the <code>await</code>.</p>
<p><code>Task.WhenAll</code> returns an array of results (one result per each input task), which is then
passed to the reporting activity.</p>
<p>Another example of parallelization could be a workflow sending e-mails to hundreds of
recipients. Such fan-out wouldn&rsquo;t be hard with normal queue-triggered functions: simply send
hundreds of messages. However, combining the results, if required for the next step
of the workflow, is quite challenging.</p>
<p>It&rsquo;s straightforward with a durable orchestrator:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#2b91af">var</span> emailSendingTasks =
</span></span><span style="display:flex;"><span>    recepients
</span></span><span style="display:flex;"><span>    .Select(to =&gt; context.CallActivityAsync&lt;<span style="color:#2b91af">bool</span>&gt;(<span style="color:#a31515">&#34;SendEmail&#34;</span>, to))
</span></span><span style="display:flex;"><span>    .ToArray();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">var</span> results = <span style="color:#00f">await</span> Task.WhenAll(emailSendingTasks);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> (results.All(r =&gt; r)) { <span style="color:#008000">/* ... */</span> }
</span></span></code></pre></div><p>Making hundreds of roundtrips to activities and back could cause numerous replays
of the orchestrator. As an optimization, if multiple activity functions complete around the same
time, the orchestrator may internally process several messages as a batch and restart
the orchestrator function only once per batch.</p>
<h2 id="other-concepts">Other Concepts</h2>
<p>There are many more patterns enabled by Durable Functions. Here is a quick list to give you some perspective:</p>
<ul>
<li>Waiting for the <em>first</em> completed task in a collection (rather than <em>all</em> of them) using the <code>Task.WhenAny</code>
method. Useful for scenarios like timeouts or competing actions.</li>
<li>Pausing the workflow for a given period or until a deadline.</li>
<li>Waiting for external events, e.g., bringing human interaction into the workflow.</li>
<li>Running recurring workflows, when the flow repeats until a certain condition is met.</li>
</ul>
<p>Further explanation and code samples are in
<a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview">the docs</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I firmly believe that serverless applications utilizing a broad range of managed cloud services
are highly beneficial to many companies, due to both rapid development process and
the properly aligned billing model.</p>
<p>Serverless tech is still young; more high-level architectural patterns need to emerge
to enable expressive and composable implementations of large business systems.</p>
<p>Azure Durable Functions suggests some of the possible answers. It combines the clarity and readability
of sequential RPC-style code with the power and resilience of event-driven architecture.</p>
<p><a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview">The documentation</a>
for Durable Functions is excellent, with plenty of examples and how-to guides.
Learn it, try it for your real-life scenarios, and let me know your opinionâ€”I&rsquo;m
excited about the serverless future!</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>Many thanks to <a href="https://twitter.com/kashimizMSFT">Katy Shimizu</a>, <a href="https://twitter.com/cgillum">Chris Gillum</a>,
<a href="https://twitter.com/efleming18">Eric Fleming</a>, <a href="https://twitter.com/KevinJonesD">KJ Jones</a>,
<a href="https://twitter.com/William_DotNet">William Liebenberg</a>, <a href="https://twitter.com/ATosato86">Andrea Tosato</a>
for reviewing the draft of this article and their valuable contributions and suggestions. The community
around Azure Functions and Durable Functions is superb!</p>

                </div>

                
                <div class="after-post-tags">
                    <ul class="tags">
                        
                        <li>
                            
                            
                            <a href="/tags/azure">Azure</a>
                            
                        </li>
                        
                        <li>
                            
                            
                            <a href="/tags/azure-functions">Azure Functions</a>
                            
                        </li>
                        
                        <li>
                            
                            
                            <a href="/tags/serverless">Serverless</a>
                            
                        </li>
                        
                        <li>
                            
                            
                            <a href="/tags/workflows">Workflows</a>
                            
                        </li>
                        
                        <li>
                            
                            
                            <a href="/tags/azure-durable-functions">Azure Durable Functions</a>
                            
                        </li>
                        
                    </ul>
                </div>
                

                <hr/>

            </div>
            
        </div>
    </div>
    
    <div class="container">
    <div id="sharepane" class="row justify-content-center">
        <div class="col-md-2">

        </div>
        <div class="contact-intro col-md-2 text-center">
            <img class="profile-small d-inline-block mx-auto rounded-circle mb-3" height="100px"
                src="/images/author.jpg" alt="">
        </div>
        <div class="col-md-8">
            <section class="article-open_author">
                <div class="article-open_author_bio">
                    <h5 itemprop="author" itemscope="" itemtype="http://schema.org/Person">Author: Mikhail Shilkov</h5>
                    <p>
                        <div>Cloud developer and researcher.</div><div>Software engineer at Pulumi. Microsoft Azure MVP.</div>
                    </p>
                </div>
            </section>
            <a href="https://twitter.com/MikhailShilkov?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @MikhailShilkov</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
        </div>
    </div>
</div>
<div class="container">
    <div id="comments" class="row justify-content-center mb-5">
        <div class="col-md-8">
            
            <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "mikhailio" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            
        </div>
    </div>
</div>
</div>

        </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright Mikhail Shilkov - All rights reserved
            </div>
            <div class="col-md-6 col-sm-6 text-center text-lg-right">    
                
            </div>
        </div>
    </div>
</footer>











<script src="/js/bundle.min.js"></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-MJW7RC6EV4"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-MJW7RC6EV4');
        }
      </script>
    </body>
</html>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Clean Code on Mikhail Shilkov</title>
    <link>https://mikhail.io/tags/clean-code/</link>
    <description>Recent content in Clean Code on Mikhail Shilkov</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>Mikhail Shilkov - All rights reserved</copyright>
    <lastBuildDate>Sat, 25 Mar 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://mikhail.io/tags/clean-code/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Visualizing Dependency Tree from DI Container</title>
      <link>https://mikhail.io/2017/03/visualizing-dependency-tree-from-di-container/</link>
      <pubDate>Sat, 25 Mar 2017 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2017/03/visualizing-dependency-tree-from-di-container/</guid>
      <description>&lt;p&gt;So you are a C# developer. And you need to read the code and understand its&#xA;structure. Maybe you&amp;rsquo;ve just joined the project, or it&amp;rsquo;s your own code you&#xA;wrote 1 year ago. In any case, reading code is hard.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dependency Inversion Implies Interfaces Are Owned by High-level Modules</title>
      <link>https://mikhail.io/2016/05/dependency-inversion-implies-interfaces-are-owned-by-high-level-modules/</link>
      <pubDate>Fri, 27 May 2016 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2016/05/dependency-inversion-implies-interfaces-are-owned-by-high-level-modules/</guid>
      <description>&lt;p&gt;Dependency Inversion is one of the five principles of widely known and&#xA;acknowledged S.O.L.I.D. design guidelines. This principle is very powerful&#xA;and useful when applied consistently. But in my experience, it&amp;rsquo;s actually&#xA;quite easy to misunderstand the idea, or at least to mentally simplify it&#xA;to somewhat less profound technique of Dependency Injection.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Validation with Either data type in C#</title>
      <link>https://mikhail.io/2016/01/validation-with-either-data-type-in-csharp/</link>
      <pubDate>Wed, 06 Jan 2016 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2016/01/validation-with-either-data-type-in-csharp/</guid>
      <description>&lt;p&gt;In this article we will employ a functional monadic concept &lt;strong&gt;Either&lt;/strong&gt; to make validation&#xA;code more expressive and easier to maintain.&lt;/p&gt;&#xA;&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s say we get a request from some client code and we need to check if this&#xA;request is actually valid. If it&amp;rsquo;s not valid, we want to make a detailed description&#xA;of the problems that we identified. If it is valid, we want to produce a response&#xA;about the successful acceptance of the request. Let&amp;rsquo;s define the classes:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Units of measurement in domain design</title>
      <link>https://mikhail.io/2015/08/units-of-measurement-in-domain-design/</link>
      <pubDate>Tue, 11 Aug 2015 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2015/08/units-of-measurement-in-domain-design/</guid>
      <description>&lt;p&gt;If you have business application of any decent size, your most important code probably resides in domain logic.&#xA;When working with 3rd party code, you can always find an answer on stack overflow or official documentation, but your domain is all yours. Try to make it as simple and readable as possible, and it will always pay you back.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

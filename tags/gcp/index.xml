<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GCP on Mikhail Shilkov</title>
    <link>https://mikhail.io/tags/gcp/</link>
    <description>Recent content in GCP on Mikhail Shilkov</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>Mikhail Shilkov - All rights reserved</copyright>
    <lastBuildDate>Tue, 05 Jan 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://mikhail.io/tags/gcp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Cold Starts in Google Cloud Functions</title>
      <link>https://mikhail.io/serverless/coldstarts/gcp/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/serverless/coldstarts/gcp/</guid>
      <description>&lt;p&gt;This article describes Google Cloud Functions—the dynamically scaled and billed-per-execution compute service. Instances of Cloud Functions are added and removed dynamically. When a new instance handles its first request, the response time suffers, which is called a &lt;strong&gt;cold start&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Comparison of Cold Starts in Serverless Functions across AWS, Azure, and GCP</title>
      <link>https://mikhail.io/serverless/coldstarts/big3/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/serverless/coldstarts/big3/</guid>
      <description>&lt;p&gt;This article compares Function-as-a-Service offerings of Big-3 cloud providers in terms of cold starts. AWS Lambda, Azure Functions (Consumption Plan), and Google Cloud Functions are all dynamically scaled and billed-per-execution compute services. Instances of cloud functions are added and removed dynamically. When a new instance handles its first request, the response time increases, which is called a &lt;strong&gt;cold start&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Google Cloud Functions: Cold Start Duration per Instance Size</title>
      <link>https://mikhail.io/serverless/coldstarts/gcp/instances/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/serverless/coldstarts/gcp/instances/</guid>
      <description>&lt;p&gt;Google Cloud Functions have a setting to define the memory size that gets allocated to a single instance of a function. The CPU resources are allocated proportionally to the memory. So, in theory, larger instances could start faster.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Google Cloud Functions: Cold Start Duration per Language</title>
      <link>https://mikhail.io/serverless/coldstarts/gcp/languages/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/serverless/coldstarts/gcp/languages/</guid>
      <description>&lt;p&gt;The following chart shows the typical range of cold starts in Google Cloud Functions, broken down per language. The darker ranges are the most common 67% of durations, and lighter ranges include 95%.&lt;/p&gt;</description>
    </item>
    <item>
      <title>When Does Cold Start Happen on Google Cloud Functions?</title>
      <link>https://mikhail.io/serverless/coldstarts/gcp/intervals/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/serverless/coldstarts/gcp/intervals/</guid>
      <description>&lt;p&gt;The very first cold start happens when the very first request comes in after deployment.&lt;/p&gt;&#xA;&lt;p&gt;After that request is processed, the instance stays alive for the time being to be reused for subsequent requests. But for how long?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hosting Azure Functions in Google Cloud Run</title>
      <link>https://mikhail.io/2020/02/azure-functions-in-google-cloud-run/</link>
      <pubDate>Fri, 14 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2020/02/azure-functions-in-google-cloud-run/</guid>
      <description>&lt;p&gt;Suppose you are a .NET developer, you love the Function-as-a-Service (FaaS) model, but you want to run your serverless functions in Google Cloud. You want to keep using C# or F#, and still leverage all serverless benefits—ease of use, scalability, elasticity, pay-per-value cost model—running in GCP.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Serverless Containers with Google Cloud Run</title>
      <link>https://mikhail.io/2020/02/serverless-containers-with-google-cloud-run/</link>
      <pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2020/02/serverless-containers-with-google-cloud-run/</guid>
      <description>&lt;p&gt;Google &lt;a href=&#34;https://cloud.google.com/run/&#34;&gt;Cloud Run&lt;/a&gt; is the latest addition to the serverless compute family. While it may look similar to existing services of public cloud, the feature set makes Cloud Run unique:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Santa Brings Cloud to Every Developer</title>
      <link>https://mikhail.io/2019/12/santa-brings-cloud-to-every-developer/</link>
      <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2019/12/santa-brings-cloud-to-every-developer/</guid>
      <description>&lt;p&gt;&lt;em&gt;The post is a part of&#xA;&lt;a href=&#34;https://sergeytihon.com/2019/11/05/f-advent-calendar-in-english-2019/&#34;&gt;F# Advent Calendar 2019&lt;/a&gt;.&#xA;It&amp;rsquo;s Christmas time!&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;Cloud is everywhere, and yet it&amp;rsquo;s still inaccessible to millions of developers and IT pros. With shining yet cloudy eyes return they from KubeCon&amp;rsquo;s and re:Invent&amp;rsquo;s, just to pick up an issue in Jira, fix yet another &lt;code&gt;SingletonProxyFactoryBean&lt;/code&gt; in their J2EE application, commit it to SVN, and hope it will be delivered in three months to the data center in their HQ basement.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Less Frequent Cold Starts in Google Cloud Functions</title>
      <link>https://mikhail.io/2019/04/less-frequent-cold-starts-in-google-cloud-functions/</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2019/04/less-frequent-cold-starts-in-google-cloud-functions/</guid>
      <description>&lt;p&gt;Several days ago, I released an update to the &lt;a href=&#34;https://mikhail.io/serverless/coldstarts/&#34;&gt;Serverless Cold Starts&lt;/a&gt; section of my website. The most significant change to the previous dataset seems to be in how GCP treats idle instances of Google Cloud Functions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Visualizing Cold Starts</title>
      <link>https://mikhail.io/2019/03/visualizing-cold-starts/</link>
      <pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2019/03/visualizing-cold-starts/</guid>
      <description>&lt;p&gt;I &lt;a href=&#34;https://mikhail.io/serverless/coldstarts/&#34;&gt;wrote a lot&lt;/a&gt; about cold starts of serverless functions. The articles are full of charts and numbers which are hopefully useful but might be hard to internalize. I decided to come up with a way to represent colds starts visually.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Serverless at Scale: Serving StackOverflow-like Traffic</title>
      <link>https://mikhail.io/2019/serverless-at-scale-serving-stackoverflow-like-traffic/</link>
      <pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2019/serverless-at-scale-serving-stackoverflow-like-traffic/</guid>
      <description>&lt;p&gt;Serverless compute is a very productive and quick way to get an application up and running. A developer writes a piece of code that solves a particular task and uploads it to the cloud. The provider handles code deployment and the ops burden of managing all the required infrastructure, so that the Function is always available, secure and performant.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From 0 to 1000 Instances: How Serverless Providers Scale Queue Processing</title>
      <link>https://mikhail.io/2018/11/from-0-to-1000-instances-how-serverless-providers-scale-queue-processing/</link>
      <pubDate>Mon, 19 Nov 2018 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2018/11/from-0-to-1000-instances-how-serverless-providers-scale-queue-processing/</guid>
      <description>&lt;p&gt;Whenever I see a &amp;ldquo;Getting Started with Function-as-a-Service&amp;rdquo; tutorial, it usually shows off&#xA;a synchronous HTTP-triggered scenario. In my projects, though, I use a lot of asynchronous&#xA;functions triggered by a queue or an event stream.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Serverless: Cold Start War</title>
      <link>https://mikhail.io/2018/08/serverless-cold-start-war/</link>
      <pubDate>Thu, 30 Aug 2018 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2018/08/serverless-cold-start-war/</guid>
      <description>&lt;p&gt;&lt;em&gt;The newer and much more detailed cold start comparison is now available: &lt;a href=&#34;https://mikhail.io/serverless/coldstarts/&#34;&gt;Cold Starts in Serverless Functions&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;Serverless cloud services are hot. Except when they are not :)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Use Fiddler to debug urlfetch requests in Google AppEngine</title>
      <link>https://mikhail.io/2012/09/02/use-fiddler-to-debug-urlfetch-requests-in-google-appengine/</link>
      <pubDate>Sun, 02 Sep 2012 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2012/09/02/use-fiddler-to-debug-urlfetch-requests-in-google-appengine/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;http://www.tripbenefit.com&#34; title=&#34;TripBenefit.com - travel in St. Petersburg, Russia&#34;&gt;TripBenefit&lt;/a&gt; application, we use a lot of web crawling to get data from third-party websites. As the application works on top of Google AppEngine, the &lt;a href=&#34;https://developers.google.com/appengine/docs/python/urlfetch/fetchfunction?hl=ru&#34; title=&#34;urlfetch.fetch() docs&#34;&gt;urlfetch.fetch()&lt;/a&gt; function is used to send HTTP requests and get responses.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Enable jinja2 and i18n translations on Google AppEngine</title>
      <link>https://mikhail.io/2012/07/26/enable-jinja2-and-i18n-translations-on-google-appengine/</link>
      <pubDate>Thu, 26 Jul 2012 00:00:00 +0000</pubDate>
      <guid>https://mikhail.io/2012/07/26/enable-jinja2-and-i18n-translations-on-google-appengine/</guid>
      <description>&lt;p&gt;My initial goal was to make our new application (based on python/AppEngine) translatable. This means the following requirements:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;All strings in the application must be translatable&lt;/li&gt;&#xA;&lt;li&gt;Translations should preferably stored in separate files&lt;/li&gt;&#xA;&lt;li&gt;It should be easy to use the translations both in .py files and html templates&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;The solution that I came to after a couple of hours includes the following components: Babel (string file generation), i18n.gettext (getting strings in code) and jinja2 &amp;lt;% trans %&amp;gt; tag (getting strings in templates). The setup of all this is not obvious, so I&amp;rsquo;ll put the steps in this blog post. Let&amp;rsquo;s start!&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
